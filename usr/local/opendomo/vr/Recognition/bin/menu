#!/bin/bash
function Retrieve_control_data()
#Retrieves control data from the system, isntead of using  temporary file /tmp/ctrl.txt
{
#Generate the data already committed, as /tmp/ctrl.txt it is already processed
					/usr/local/opendomo/services/config/manageControlDevices.sh |grep -| awk '{ print $2}' > /tmp/ctrl2.txt
					echo -n "" > /tmp/ctrl.txt
					while read line
					do
						echo $line ":::::::existente " >> /tmp/ctrl.txt
					done < /tmp/ctrl2.txt				
					rm /tmp/ctrl2.txt		
}
#******************************************************************************************************************************************************
function Generate_control_data()
#Create temporary file to store control devices  data
{
		cat /tmp/ctrl.txt |cut -d":" -f1 > /tmp/tmp.txt 
                echo " Placas disponibles: " >> /tmp/tmp.txt     
		grep Card /etc/opendomo/speech/portmenu.txt |sed  -e "s/Card:/placa /" |sed -e "s/:/ diga, control placa {$par1} /" >> /tmp/tmp.txt
		echo " Puertos disponibles: " >> /tmp/tmp.txt
		grep Port /etc/opendomo/speech/portmenu.txt |sed  -e "s/Port:/puerto /" |sed -e "s/:/ diga, control puerto {$par1} /" >> /tmp/tmp.txt
}
#******************************************************************************************************************************************************
function Prepare_actual_zone_data()
{
		echo -n "" > /tmp/tmp.txt				
		while read line 
		do	
			zona=`echo $line | cut -d":" -f1 -`
			descr=`echo $line | cut -d":" -f2 -`
			coord=`echo $line | cut -d":" -f4 -`
			if [ "$coord" == "" ]
			then
				coordenadas=""
			else
				coordenadas=" coordenadas  {$coord}" 
			fi
			if [ "$descr" == "" ]
			then
				descripcion=""
			else
				descripcion=" descripcion {$descr}" 
			fi
			if [ `echo $line | grep -c "nueva"` -gt 0 ]
			then
				estado=" marcada para ser creada "
			elif [ `echo $line | grep -c "borrar"` -gt 0 ]
			then
				estado=" marcada para ser borrada "
			else
				estado=""
			fi
			echo $zona $descripcion $coordenadas $estado >> /tmp/tmp.txt
		done < /tmp/zone.txt
}
#******************************************************************************************************************
function Generate_plugin_data()
{
#create temporary file for keeping provisional states data, until new states data data is saved 
			  	/usr/local/opendomo/managePlugins.sh | grep "image plugin" > /tmp/tmp.txt
				i=0
				echo -n "" > /tmp/plugin.txt				
				while read line 
				do
					((i++))	
					plugin=`echo $line | awk '{print $1}'`
					echo -n $plugin >> /tmp/plugin.txt
					if [ `echo $line | grep -c "new"` -gt 0 ]
					then
						echo " numero " $i " estado no instalado" >> /tmp/plugin.txt
					else	
						echo " numero " $i " estado instalado" >> /tmp/plugin.txt
					fi
				done < /tmp/tmp.txt
				rm /tmp/tmp.txt
}
#****************************************************************************************************************
function Retrieve_initial_interface_data()
{
	
	theme=`cat /tmp/itf.txt | grep Theme | awk '{ print $4}'`
	skin=`cat /tmp/itf.txt | grep Skin | awk '{ print $4}'`
	langshort=`cat /tmp/itf.txt | grep Language | awk '{ print $6}'`
	case "$langshort" in
		es)
		language="Castellano"
		;;
		ca)
		language="Catalan"
		;;
		en)
		language="English"
		;;
		eu)
		language="Euskera"
		;;
		fr)
		language="Francais"
		;;
		ga)
		language="Galego"
		;;
		else)
		;;
	esac
}
#**************************************************************************************
function Retrieve_actual_interface_data()
{
	
	theme=`cat /tmp/itf.txt | grep Tema | awk '{ print $2}'`
	skin=`cat /tmp/itf.txt | grep Piel | awk '{ print $2}'`
	language=`cat /tmp/itf.txt | grep Idioma | awk '{ print $2}'`
}
#**************************************************************************************
function Inform_about_interface_actual_data ()
{
				echo "Configuracion de interface actual" > /tmp/itf.txt
				echo "Tema: " $theme >> /tmp/itf.txt
				echo "Piel: " $skin >> /tmp/itf.txt
				echo "Idioma: " $language >> /tmp/itf.txt
				$ESPEAK < /tmp/itf.txt
				
}
#**************************************************************************************
#main
#**************************************************************************************
read ESPEAK < /etc/opendomo/speech/espeak.dat
read menu < /usr/local/opendomo/vr/MENU
if [ "$1" = "0" ]
then
	# This option, restarts MENU, to the first level	
	/usr/local/opendomo/vr/espeak.sh Menu0
	echo "menu0" > /usr/local/opendomo/vr/MENU
elif [ "$1" = "21" ]
then
	#21 ==> Salir del modo menú
	/usr/local/opendomo/vr/espeak.sh Menusalir
	echo "no" > /usr/local/opendomo/vr/MENU
elif [ "$1" = "20" ]
then
	#20 ==> Volver al menu anterior.
	# Por reagrupación de codige mejor tratarlo junto
	case "$menu" in
	menu0)
		#20 ==> Volver. En este caso, como estamos en el Menu principal (Menu0) repetimos el mismo Menu0
		/usr/local/opendomo/vr/espeak.sh Menu0
		echo "menu0" > /usr/local/opendomo/vr/MENU
		;;
	menu1|menu2|menu3)	
		#20 ==> Volver
		/usr/local/opendomo/vr/espeak.sh Menu0
		echo "menu0" > /usr/local/opendomo/vr/MENU
		;;		
	menu11|menu12)
		#20 ==> Volver
		/usr/local/opendomo/vr/espeak.sh Menu1e
		echo "menu1" > /usr/local/opendomo/vr/MENU
		;;
	menu3xconf|menu3xvoice|menu3xnet|menu3xitf|menu3xuser|menu3xctl|menu3xstat|menu3xplug|menu3xzon)
		#20 ==> Volver
		$ESPEAK < /etc/opendomo/speech/configmenu.txt
		echo "menu3" > /usr/local/opendomo/vr/MENU
		;;
	menu3xstatmod)
		#20 ==> Volver
		$ESPEAK "Menu de configuracion de estados del sistema. Estados actuales "
		#create temporary file for keeping provisional states data, until new states data data is saved 
		ls -l /etc/opendomo/states | awk '{ print $9}' > /tmp/stat.txt
		$ESPEAK < /tmp/stat.txt
		echo "menu3xstat" > /usr/local/opendomo/vr/MENU
		;;
	menu111|menu112|menu113|menu114|menu115|menu116|menu117)
		# This option, restarts MENU, to the previous level	
		/usr/local/opendomo/vr/espeak.sh Menu11e
		echo "menu11" > /usr/local/opendomo/vr/MENU
		;;
	esac

elif [ "$1" = "22" ]
then
	#22 ==> Donde estoy?.
	/usr/local/opendomo/vr/espeak.sh MenuDonde
	# Por reagrupación de código mejor tratarlo junto
	case "$menu" in
	no)
		read mode < /usr/local/opendomo/vr/MODE
		if [ "$mode" = "main" ]
		then
			/usr/local/opendomo/vr/espeak.sh DondeestoyNormal
		else
			
			/usr/local/opendomo/vr/espeak.sh DondeestoyIdentificacion
		fi
		;;	
	menu0)
		/usr/local/opendomo/vr/espeak.sh Menu0
		;;
	menu1)	
		/usr/local/opendomo/vr/espeak.sh Menu1e
		;;
	menu11)	
		/usr/local/opendomo/vr/espeak.sh Menu11e
		;;
	menu12)	
		/usr/local/opendomo/vr/espeak.sh Menu12e
		;;				
	menu3)
		$ESPEAK < /etc/opendomo/speech/configmenu.txt
		;;
	menu111)
		$ESPEAK < /etc/opendomo/speech/lightmenu.txt		
		;;

	menu112)
		$ESPEAK < /etc/opendomo/speech/climamenu.txt		
		;;
	menu113)
		$ESPEAK < /etc/opendomo/speech/musicmenu.txt		
		;;
	menu114)
		$ESPEAK < /etc/opendomo/speech/videomenu.txt		
		;;
	menu115)
		$ESPEAK < /etc/opendomo/speech/sensorsmenu.txt		
		;;
	menu116)
		$ESPEAK < /etc/opendomo/speech/varclimatemenu.txt		
		;;

	menu117)
		$ESPEAK < /etc/opendomo/speech/varlightmenu.txt		
		;;
	menu2)
		##To be filled in	
		;;
	menu3xconf)
		/usr/local/opendomo/vr/espeak.sh Menuconfigsave		
		;;
	menu3xvoice)
		read IDIOMA < /etc/opendomo/lang
		cd /usr/local/opendomo/vr/characters/$IDIOMA
		echo "Configuracion de reconocimiento de voz " > /tmp/tmp.txt
		echo "Seleccione a continuacion el personaje que desea" >> /tmp/tmp.txt
						
		for voz in `ls | cut -f1 -d. |uniq `  
		do	
			echo -n " Para configurar voz de " >> /tmp/tmp.txt
			echo -n $voz >> /tmp/tmp.txt
			echo -n " ,diga voz de " >> /tmp/tmp.txt
			echo $voz >> /tmp/tmp.txt
		done
		$ESPEAK < /tmp/tmp.txt
		rm /tmp/tmp.txt	
		;;
	menu3xnet)
		$ESPEAK "Menu de configuracion de red "
		$ESPEAK < /etc/opendomo/speech/netmenu.txt
		/usr/local/opendomo/vr/espeak.sh MenuNetConfig	
		;;
	menu3xitf)
		$ESPEAK < /etc/opendomo/speech/INTERFACE	
		;;
	menu3xusr)
		$ESPEAK "Menu de configuracion de usuarios. Usuarios actuales "
		$ESPEAK < /tmp/usr.txt
		/usr/local/opendomo/vr/espeak.sh MenuUserConfig		
		;;
	menu3xctl)
		$ESPEAK "Menu de configuracion de puertos de control. Puertos actuales "
		Generate_control_data
		$ESPEAK < /tmp/tmp.txt
		/usr/local/opendomo/vr/espeak.sh MenuControlConfig
		;;
	menu3xstat)
		$ESPEAK "Menu de configuracion de estados del sistema.Estados actuales "
		#create temporary file for keeping provisional states data, until new states data data is saved 
		ls -l /etc/opendomo/states | awk '{ print $9}' > /tmp/stat.txt
		$ESPEAK < /tmp/stat.txt
		/usr/local/opendomo/vr/espeak.sh MenuStatConfig
		;;
	menu3xstatmod)
		$ESPEAK "Menu de configuracion de un estado del sistema "
		estado=`cat /var/opendomo/tmp/state.tmp` 
		echo " Estado " $estado " Valores actuales: " > /tmp/tmp.txt
		cat /tmp/stat2.txt >> /tmp/tmp.txt
		echo " Diga , estado activar numero para activar un demonio, o , estado desactivar numero para desactivar un demonio " >> /tmp/tmp.txt
		echo " Diga , estado ejecutar " $estado " para guardar los cambios " >> /tmp/tmp.txt
		$ESPEAK < /tmp/tmp.txt
		;;
	menu3xplug)
		$ESPEAK "Menu de configuracion de complementos del sistema. Estado actual  "
		Generate_plugin_data
		$ESPEAK < /tmp/plugin.txt
		/usr/local/opendomo/vr/espeak.sh MenuPlugConfig
		;;
	menu3xzone)
		$ESPEAK "Menu de configuracion de znas del sistema. Zonas actuales  "
		Prepare_actual_zone_data
		$ESPEAK < /tmp/tmp.txt
		/usr/local/opendomo/vr/espeak.sh MenuZoneConfig
		;;
	esac


else
	
	#Clean posible "opción" prefix
	par1=`echo $1 |cut -d " " -f1 -`
	if [ "$par1" = "opción" ]
	then
		p1=`echo $1 |cut -d " " -f2 -`
	else
		p1=`echo $1 |cut -d " " -f1 -`
	fi
	case "$menu" in
	no)
		/usr/local/opendomo/vr/espeak.sh MenuNo
		;;	
	menu0)
		case "$p1" in
			1)
			/usr/local/opendomo/vr/espeak.sh Menu1e
			echo "menu1" > /usr/local/opendomo/vr/MENU 
			;;
			2)
			/usr/local/opendomo/vr/espeak.sh Menu2e
			echo "menu2" > /usr/local/opendomo/vr/MENU
			;; 
			3)
			$ESPEAK < /etc/opendomo/speech/configmenu.txt
			echo "menu3" > /usr/local/opendomo/vr/MENU
			;;
			else)
			#Opción no válida. Repetir opciones de menu, y quedarse en el mismo estado
			/usr/local/opendomo/vr/espeak.sh Menunoval Menu0
			;;   
		esac
		;;
	menu1)
		case "$p1" in
			1)
			#Listar controladores
			# Agrupar controladores por tipo, de acuerdo a lo que hay en AYUDA
			/usr/local/opendomo/vr/espeak.sh Menu11e
			echo "menu11" > /usr/local/opendomo/vr/MENU
			;; 
			2)
			#Cambiar estado
			#Preguntar estado  y acabar
			/usr/local/opendomo/vr/espeak.sh Menu12e
			echo "menu12" > /usr/local/opendomo/vr/MENU
			;; 

			else)
			#Opción no válida. Repetir opciones de menu, y quedarse en el mismo estado
			/usr/local/opendomo/vr/espeak.sh Menunoval Menu1e
			;;   

		esac
		;;
	menu3)
		#get the script to be run:
		line=`grep -m 1 $p1 /etc/opendomo/speech/CONFIG`
		script=`echo -n $line | cut -d":" -f2 `
		
		case "$script" in
			about.sh)
				/usr/local/opendomo/services/config/about.sh > /tmp/tmp.txt
				echo "Informacion de instalacion OpenDomo" > about.txt
				version=`grep INF /tmp/tmp.txt |  cut -d ":" -f2 -`
				echo "version  de OpenDomo " $version >> about.txt
				kernel=`grep kernel /tmp/tmp.txt | awk '{ print $5}'`
				echo -n "Version del kernel " >> about.txt
				echo $kernel >> about.txt
				echo " Paquetes instalados " >> about.txt
				for plugin in `grep version /tmp/tmp.txt | cut -f1 -d.`
				do
        				echo $plugin >> about.txt
				done
				$ESPEAK < about.txt
				rm about.txt
				rm /tmp/tmp.txt
				;;			
			reboot.sh)
				$ESPEAK " Rearrancando el sistema "
				/usr/local/opendomo/services/config/reboot.sh > reboot.txt
				;;
			manageConfiguration.sh)
				echo "menu3xconf" > /usr/local/opendomo/vr/MENU
				/usr/local/opendomo/vr/espeak.sh Menuconfigsave
				;;
			configureVoiceSystem.sh)
				echo "menu3xvoice" > /usr/local/opendomo/vr/MENU
				read IDIOMA < /etc/opendomo/lang
				cd /usr/local/opendomo/vr/characters/$IDIOMA
				echo "Configuracion de reconocimiento de voz " > /tmp/tmp.txt
				echo "Seleccione a continuacion el personaje que desea" >> /tmp/tmp.txt
						
				for voz in `ls | cut -f1 -d. |uniq `  
				do	
					echo -n " Para configurar voz de " >> /tmp/tmp.txt
					echo -n $voz >> /tmp/tmp.txt
					echo -n " ,diga voz de " >> /tmp/tmp.txt
					echo $voz >> /tmp/tmp.txt
				done
				$ESPEAK < /tmp/tmp.txt
				rm /tmp/tmp.txt
				;;
			configLocalNetwork.sh)
				echo "menu3xnet" > /usr/local/opendomo/vr/MENU
				$ESPEAK < /etc/opendomo/speech/netmenu.txt
				/usr/local/opendomo/vr/espeak.sh MenuNetConfig
				;;
			configureInterface.sh)
				echo "menu3xitf" > /usr/local/opendomo/vr/MENU
				/usr/local/opendomo/services/config/configureInterface.sh > /tmp/itf.txt
				Retrieve_initial_interface_data
				Inform_about_interface_actual_data
				$ESPEAK < /etc/opendomo/speech/INTERFACE
				;;
			manageUsers.sh)
				echo "menu3xusr" > /usr/local/opendomo/vr/MENU
				#List actual users
				$ESPEAK "Menu de configuracion de usuarios. Usuarios actuales "
				#create temporary file for keeping provisional user data, until user data is saved 
				ls -l /etc/opendomo/udata |grep .info |cut -d"." -f1 | awk '{ print $9}' > /tmp/usr.txt
				$ESPEAK < /tmp/usr.txt
				/usr/local/opendomo/vr/espeak.sh MenuUserConfig
				;;
			manageControlDevices.sh)
				echo "menu3xctl" > /usr/local/opendomo/vr/MENU
				#List actual control data
				$ESPEAK "Menu de configuracion de dispositivos de control. Dispositivos actuales "
				Retrieve_control_data				
				Generate_control_data				
				$ESPEAK < /tmp/tmp.txt
				/usr/local/opendomo/vr/espeak.sh MenuControlConfig
				;;
			manageSystemStates.sh)
				echo "menu3xstat" > /usr/local/opendomo/vr/MENU
				#List actual control data
				$ESPEAK "Menu de configuracion de estados del sistema. Estados actuales "
				#create temporary file for keeping provisional states data, until new states data data is saved 
			  	ls -l /etc/opendomo/states | awk '{ print $9}' > /tmp/stat.txt
				$ESPEAK < /tmp/stat.txt
				/usr/local/opendomo/vr/espeak.sh MenuStatConfig
				;;
			managePlugins.sh)
				echo "menu3xplug" > /usr/local/opendomo/vr/MENU
				#List actual plugin data
				$ESPEAK "Menu de configuracion de complementos o plugins del sistema. Complementos actuales "
				Generate_plugin_data
				$ESPEAK < /tmp/plugin.txt
				/usr/local/opendomo/vr/espeak.sh MenuPlugConfig
				;;
			manageZones.sh)
				echo "menu3xzon" > /usr/local/opendomo/vr/MENU
				#List actual zone data
				$ESPEAK "Menu de configuracion de zonas  del sistema. Zonas actuales "
				/usr/local/opendomo/manageZones.sh | grep - | sed 's/-//g' | awk '{print $1":" $2":" $3":"}' > /tmp/zone.txt
				Prepare_actual_zone_data
				$ESPEAK < /tmp/tmp.txt
				/usr/local/opendomo/vr/espeak.sh MenuZoneConfig
				;;
			else)
				$ESPEAK " Opcion no implementada "
				;;
		esac
		;;
	menu11)
		case "$p1" in
			1)
			#Luces
			# 
			$ESPEAK < /etc/opendomo/speech/lightmenu.txt
			echo "menu111" > /usr/local/opendomo/vr/MENU
			;; 
			2)
			#Clima
			# 
			$ESPEAK < /etc/opendomo/speech/climamenu.txt
			echo "menu112" > /usr/local/opendomo/vr/MENU
			;; 
			3)
			#Musica
			# 
			$ESPEAK < /etc/opendomo/speech/musicmenu.txt
			echo "menu113" > /usr/local/opendomo/vr/MENU
			;; 
			4)
			#VideoVigilancia
			# 
			$ESPEAK < /etc/opendomo/speech/videomenu.txt
			echo "menu114" > /usr/local/opendomo/vr/MENU
			;; 
			5)
			#Sensores
			# 
			$ESPEAK < /etc/opendomo/speech/sensorsmenu.txt
			echo "menu115" > /usr/local/opendomo/vr/MENU
			;; 
			6)
			#Termostatos
			# 
			$ESPEAK < /etc/opendomo/speech/varclimatemenu.txt
			echo "menu116" > /usr/local/opendomo/vr/MENU
			;; 
			7)
			#Reguladores de Luz
			# 
			$ESPEAK < /etc/opendomo/speech/varlightmenu.txt
			echo "menu117" > /usr/local/opendomo/vr/MENU
			;; 

			else)
			#Opción no válida. Repetir opciones de menu, y quedarse en el mismo estado
			/usr/local/opendomo/vr/espeak.sh Menunoval Menu11e
			;;   

		esac
		;;
	menu12)
		case "$p1" in
			1)
			#Pasar a modo activo
			#
			/usr/local/opendomo/setSystemState.sh activ
			/usr/local/opendomo/vr/espeak.sh Menucambestactiv
			;; 
			2)
			#Pasar a modo vigilancia
			#
			/usr/local/opendomo/setSystemState.sh secured
			/usr/local/opendomo/vr/espeak.sh Menucambestvig
			;; 
			3)
			#Pasar a modo desactivado
			#Volver luego al menu anterior
			/usr/local/opendomo/setSystemState.sh sleeping
			/usr/local/opendomo/vr/espeak.sh Menucambestdesac
			;; 
		
			else)
			#Opción no válida. Repetir opciones de menu, y quedarse en el mismo estado
			/usr/local/opendomo/vr/espeak.sh Menunoval Menu12
			;;   

		esac
		;;
	menu3xconf)
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`
		par3=`echo $1 |cut -d " " -f3 -`
		
		case "$par2" in
			1)
			$ESPEAK " Salvando configuracion actual con plugins. Espere a oir de nuevo el bip"
			echo "on" > /var/opendomo/tmp/savestatus
			/usr/local/opendomo/saveSystemConfig.sh
			;;
			2)
			$ESPEAK " Salvando configuracion actual sin plugins. Espere a oir de nuevo el bip"
			echo "off" > /var/opendomo/tmp/savestatus
			/usr/local/opendomo/saveSystemConfig.sh
			;;	
			3)
			$ESPEAK " Salvando configuracion de defecto con plugins.Espere a oir de nuevo el bip"
			echo "on" > /var/opendomo/tmp/savestatus
			/usr/local/opendomo/loadDefaultConfig.sh
			;;	
			4)
			$ESPEAK " Salvando configuracion de defecto sin plugins. Espere a oir de nuevo el bip"
			echo "off" > /var/opendomo/tmp/savestatus
			/usr/local/opendomo/loadDefaultConfig.sh
			;;	
			else)
			;;				
		esac
		;;
	menu3xvoice)
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`
		par3=`echo $1 |cut -d " " -f3 -`				
		par3=${par3,,}				
		read IDIOMA < /etc/opendomo/lang
		cd /usr/local/opendomo/vr/characters/$IDIOMA				
		if [ `ls | grep -c $par3` -eq 1 ]
		then				
			/usr/local/opendomo/services/config/configureVoiceSystem.sh $par3
			echo -n "Cambiada la voz del personaje a " > /tmp/tmp.txt
			echo $par3 >> /tmp/tmp.txt
		else
			echo "No existe el personaje " $par3 > /tmp/tmp.txt
			echo "Seleccione a continuacion el personaje que desea" >> /tmp/tmp.txt
						
			for voz in `ls | cut -f1 -d. |uniq `   
			do	
				echo -n " Para configurar voz de " >> /tmp/tmp.txt
				echo -n $voz >> /tmp/tmp.txt
				echo -n " ,diga voz de " >> /tmp/tmp.txt
				echo $voz >> /tmp/tmp.txt
			done
		fi
		$ESPEAK < /tmp/tmp.txt		
		rm /tmp/tmp.txt
		;;
	menu3xnet)
		#First check actual configuration saved in /etc/opendomo/speech/netmenu.txt
		MODE=`cat /etc/opendomo/speech/netmenu.txt |grep modo | awk '{ print $2}'`
		IP=`cat /etc/opendomo/speech/netmenu.txt |grep IP | awk '{ print $2}'`
		MASK=`cat /etc/opendomo/speech/netmenu.txt |grep mascara | awk '{ print $2}'`
		GW=`cat /etc/opendomo/speech/netmenu.txt |grep puerta | awk '{ print $4}'`
		DNS=`cat /etc/opendomo/speech/netmenu.txt |grep DNS | awk '{ print $2}'`
		echo $MODE $IP $MASK $GW $DNS
		par1=`echo $2 |cut -d " " -f1 -`
		par2=`echo $2 |cut -d " " -f2 -`
		par3=`echo $2 |cut -d " " -f3 -`
		par4=`echo $2 |cut -d " " -f4 -`
		case "$1" in
			redmode)
				case "$par3" in
					estático)
					MODE="static"
					;;
					DHCP)
					MODE="dhcp"
					;;	
					else)
					/usr/local/opendomo/vr/espeak.sh Menunoval
					;;
						
				esac
				;;
			redIP)
				IP=$par1"."$par2"."$par3"."$par4
				;;
			redmask)
				MASK=$par1"."$par2"."$par3"."$par4
				;;
			redGW)
				GW=$par1"."$par2"."$par3"."$par4
				;;
			redDNS)
				DNS=$par1"."$par2"."$par3"."$par4
				;;
			redsave)
				/usr/local/opendomo/services/config/configLocalNetwork.sh $MODE $IP $MASK $GW $DNS > /tmp/tmp.txt
			
				if [ `cat /tmp/tmp.txt | grep -c "#ERR"` -gt 0 ]
				then
					/usr/local/opendomo/vr/espeak.sh MenuNetSalvarErr
				else
					/usr/local/opendomo/vr/espeak.sh MenuNetsalvarOk
					echo "menu3" > /usr/local/opendomo/vr/MENU
					exit 0
				fi		
				rm /tmp/tmp.txt
				;;
			else)
				;;
		esac
		echo "Configuracion de red " > /etc/opendomo/speech/netmenu.txt
		echo "Valores actuales " > /etc/opendomo/speech/netmenu.txt
		echo " modo " $MODE >> /etc/opendomo/speech/netmenu.txt
		echo " IP " $IP >> /etc/opendomo/speech/netmenu.txt
		echo " mascara " $MASK >> /etc/opendomo/speech/netmenu.txt
		echo " puerta de enlace " $GW >> /etc/opendomo/speech/netmenu.txt
		echo " DNS " $DNS >> /etc/opendomo/speech/netmenu.txt
		$ESPEAK < /etc/opendomo/speech/netmenu.txt	
		;;
	menu3xitf)
		Retrieve_actual_interface_data		
		par1=`echo $2 |cut -d " " -f1 -`
		par2=`echo $2 |cut -d " " -f2 -`
		par3=`echo $2 |cut -d " " -f3 -`
		par4=`echo $2 |cut -d " " -f4 -`
		case "$1" in
			tema)
				theme=`grep "tema" /etc/opendomo/speech/INTERFACE |grep $par3 |awk '{ print $3}'`
				;;
			piel)
				skin=`grep "piel" /etc/opendomo/speech/INTERFACE |grep $par3 |awk '{ print $3}'`
				;;
			idioma)
				language=`grep "idioma" /etc/opendomo/speech/INTERFACE |grep $par3 |awk '{ print $6}'`
				;;
			interfazayuda)
				$ESPEAK < /etc/opendomo/speech/INTERFACE
				;;
			interfazsalvar)
				#Don't do anything here, first, tell user which is the final interface look to save
				;;
			else)
				$ESPEAK < /etc/opendomo/speech/INTERFACE
				;;
		esac
		Inform_about_interface_actual_data
		#Nota: Si venimos de configuración inicial , el idioma está almacenado con . al final: Eukera. Si se configura por 			
		# el usuario viene sin . ....Cosas que hay que hacer...fine tunning		
		if [ "$1" = "interfazsalvar" ]
		then
			case "$language" in
				Castellano|Spanish)
				langshort="es"
				;;
				Catalan)
				langshort="ca"
				;;
				English)
				langshort="en"
				;;
				Euskera)
				langshort="eu"
				;;
				Francais)
				langshort="fr"
				;;
				Galego)
				langshort="ga"
				;;
				else)
				;;
			esac			
			/usr/local/opendomo/services/config/configureInterface.sh $theme $skin $langshort
			$ESPEAK "Los datos de configuracion de interfaz anteriores han sido salvados"
		else
			$ESPEAK "Si necesita ayuda para configurar el interfaz diga interfaz ayuda"
		fi
		;;
	menu3xusr)
		#data for new user is in /tmp/usr.txt. Data is structured in : user:fullname:mail:password
		par1=`echo $2 |cut -d " " -f1`
		# To avoid problems with capitals, let'sfix all user to caps off
		par1=${par1,,} 
		par2=`echo $2 |cut -d " " -f2-`
		case "$1" in
			usuariocrear)
				if [ `grep -c $par1 /tmp/usr.txt` -eq 0 ]
				then
					echo $par1 "::::nuevo " >> /tmp/usr.txt
					echo "usuario " $par1 "va a ser creado ""Debe de completar los datos de nombre completo, email y clave. Para confirmar la creacion diga usuario ejecutar" $par1 > /tmp/tmp.txt 	
				else
					echo "El usuario " $par1 " ya existe" >> /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt	
				;;
			usuarioborrar)
				if [ `grep -c $par1 /tmp/usr.txt` -gt 0 ]
				then
					# leer linea de usr.txt y cambiar la que tiene $2 por $2:usuario a borrar
					i=0
					echo "" > /tmp/usr2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							echo $par1 "::::borrar" >> /tmp/usr2.txt
						else
							echo $line >> /tmp/usr2.txt
						fi
					done < /tmp/usr.txt
					cp /tmp/usr2.txt /tmp/usr.txt
					rm /tmp/usr2.txt
					echo "Usuario " $par1 " marcado para ser borrado "" Para confirmar el borrado diga usuario ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El usuario " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			usuariomodnombre)
				if [ `grep -c $par1 /tmp/usr.txt` -gt 0 ]
				then
					# leer linea de usr.txt y cambiar la que tiene $2 por $2:usuario a borrar
					i=0
					echo "" > /tmp/usr2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							string=`cat tmp.txt | cut -d":" -f2`
							line=`cat tmp.txt | sed  -e "s/\$string/\$par2/"`	
						fi
						echo $line >> /tmp/usr2.txt
					done < /tmp/usr.txt
					cp /tmp/usr2.txt /tmp/usr.txt
					rm /tmp/usr2.txt					
						
					echo "Usuario " $par1 " Nombre completo " $par2 " Para confirmar el cambio diga usuario ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El usuario " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			usuariomodcorreo)
				if [ `grep -c $par1 /tmp/usr.txt` -gt 0 ]
				then
					# leer linea de usr.txt y cambiar la que tiene $2 por $2:usuario a borrar
					i=0
					echo "" > /tmp/usr2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							string=`cat tmp.txt | cut -d":" -f3`
							line=`cat tmp.txt | sed  -e "s/\$string/\$par2/"`	
						fi
						echo $line >> /tmp/usr2.txt
					done < /tmp/usr.txt
					cp /tmp/usr2.txt /tmp/usr.txt
					rm /tmp/usr2.txt					
						
					echo "Usuario " $par1 " Correo " $par2 " Para confirmar el cambio diga usuario ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El usuario " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt				
				;;
			usuariomodclave)
				if [ `grep -c $par1 /tmp/usr.txt` -gt 0 ]
				then
					# leer linea de usr.txt y cambiar la que tiene $2 por $2:usuario a borrar
					i=0
					echo "" > /tmp/usr2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							string=`cat tmp.txt | cut -d":" -f3`
							line=`cat tmp.txt | sed  -e "s/\$string/\$par2/"`	
						fi
						echo $line >> /tmp/usr2.txt
					done < /tmp/usr.txt
					cp /tmp/usr2.txt /tmp/usr.txt
					rm /tmp/usr2.txt					
						
					echo "Usuario " $par1 " Clave de usuario " $par2 " Para confirmar el cambio diga usuario ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El usuario " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt						
				;;
			usuarioejecutar)
				#Don't do anything here, do it after, helping in other case, with option usuario ayuda 
				;;
			usuarioayuda|else)
				$ESPEAK "Menu de configuracion de usuarios. Usuarios actuales "
				$ESPEAK < /tmp/usr.txt
				/usr/local/opendomo/vr/espeak.sh MenuUserConfig		
				;;
		esac
				
		if [ "$1" = "usuarioejecutar" ]
		then
			grep $par1 /tmp/usr.txt > /tmp/tmp.txt
			if [ `grep -c "borrar" /tmp/tmp.txt` -gt 0 ]
			then
				/usr/local/opendomo/deleteUser.sh $par1
				# leer linea de usr.txt y cambiar la que tiene $2 por linea vacia
					i=0
					echo "" > /tmp/usr2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							echo "" >> /tmp/usr2.txt
						else
							echo $line >> /tmp/usr2.txt
						fi
					done < /tmp/usr.txt
					cp /tmp/usr2.txt /tmp/usr.txt
					rm /tmp/usr2.txt
				echo "Usuario " $par1 " ha sido borrado " > /tmp/tmp.txt
			else
				nombre=`cat /tmp/tmp.txt | cut -d":" -f2`
				email=`cat /tmp/tmp.txt | cut -d":" -f3`
				clave=`cat /tmp/tmp.txt | cut -d":" -f4`
				/usr/local/opendomo/modifyUser $par1 $nombre $email $clave
				echo "Usuario " $par1 " ha sido modificado " > /tmp/tmp.txt 
			fi 			
			$ESPEAK < /tmp/tmp.txt
		else
			$ESPEAK "Si necesita ayuda para modificar datos de usuario, diga usuario ayuda"
		fi
		;;
	#Control devices
	menu3xctl)
	#data for new user is in /tmp/ctrl.txt. Data is structured in : 					   			
	#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
		par1=`echo $2 |cut -d " " -f1`
		# To avoid problems with capitals, let'sfix all data to caps off
		par1=${par1,,} 
		par2=`echo $2 |cut -d " " -f2-`
		case "$1" in
			controlcrear)
				if [ `grep -c $par1 /tmp/ctrl.txt` -eq 0 ]
				then
					echo $par1 ":::::::nuevo " >> /tmp/ctrl.txt
					echo "dispositivo " $par1 "va a ser creado. ""Debe de completar los datos de placa ,puerto, tiempo de refresco, direccion IP, usuario y clave. Para confirmar los cambios diga control ejecutar" $par1 > /tmp/tmp.txt 
				else
					echo "El dispositivo " $par1 " ya existe" >> /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt	
				;;
			controlborrar)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# leer linea de ctrl.txt y cambiar la que tiene $2 por $2:dispositivo a borrar
					i=0
					echo -n "" > /tmp/ctrl2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							echo $par1 ":::::::borrar" >> /tmp/ctrl2.txt
						else
							echo $line >> /tmp/ctrl2.txt
						fi
					done < /tmp/ctrl.txt
					cp /tmp/ctrl2.txt /tmp/ctrl.txt
					rm /tmp/ctrl2.txt
					echo "Dispositivo " $par1 " marcado para ser borrado "" Para confirmar el borrado diga control ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			controlplaca)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# Check the card 
					i=0
					if [ `grep -c Card /etc/opendomo/speech/portmenu.txt` -ge $par2 ]
					then
						card=`grep Card /etc/opendomo/speech/portmenu.txt | grep $par2 | cut -d":" -f2`
						echo -n "" > /tmp/ctrl2.txt
						while read line
						do	
							((i++))		
							echo $line > /tmp/tmp.txt
							if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
							then
								# cambiar el campo 2 por el parametro $par2
								# Sacar todos los campos y sustituir el 2 por $card
								#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
								port=`cat /tmp/tmp.txt | cut -d":" -f3`
								refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
								ip=`cat /tmp/tmp.txt | cut -d":" -f5`
								user=`cat /tmp/tmp.txt | cut -d":" -f6`
								passw=`cat /tmp/tmp.txt | cut -d":" -f7`
								inf=`cat /tmp/tmp.txt | cut -d":" -f8`
								line=$par1":"$card":"$port":"$refresh":"$ip":"$user":"$passw":"$inf	
							fi
							echo $line >> /tmp/ctrl2.txt
						done < /tmp/ctrl.txt
						cp /tmp/ctrl2.txt /tmp/ctrl.txt
						rm /tmp/ctrl2.txt
						echo "Configurado " $card " en dispositivo " $par1  > /tmp/tmp.txt		
					else
						echo " Numero de placa incorrecto. Valores posibles " > /tmp/tmp.txt
						grep Card /etc/opendomo/speech/portmenu.txt |sed  -e "s/Card:/placa /" |sed -e "s/:/ diga, control placa {$par1} /" >> /tmp/tmp.txt
					fi						
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			controlpuerto)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# Check the port 
					i=0
					if [ `grep -c Port /etc/opendomo/speech/portmenu.txt` -ge $par2 ]
					then
						port=`grep Port /etc/opendomo/speech/portmenu.txt | grep $par2 | cut -d":" -f2`
						echo -n "" > /tmp/ctrl2.txt
						while read line
						do	
							((i++))		
							echo $line > /tmp/tmp.txt
							if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
							then
								# cambiar el campo 2 por el parametro $par2
								# Sacar todos los campos y sustituir el 2 por $card
								#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
								card=`cat /tmp/tmp.txt | cut -d":" -f2`
								refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
								ip=`cat tmp.txt | cut -d":" -f5`
								user=`cat /tmp/tmp.txt | cut -d":" -f6`
								passw=`cat /tmp/tmp.txt | cut -d":" -f7`
								inf=`cat /tmp/tmp.txt | cut -d":" -f8`
								line="$par1":"$card":"$port":"$refresh":"$ip":"$user":"$passw":"$inf"	
							fi
							echo $line >> /tmp/ctrl2.txt
						done < /tmp/ctrl.txt
						cp /tmp/ctrl2.txt /tmp/ctrl.txt
						rm /tmp/ctrl2.txt
						echo "Configurado " $port " en dispositivo " $par1  > /tmp/tmp.txt		
					else
						echo " Numero de puerto incorrecto. Valores posibles " > /tmp/tmp.txt
						grep Port /etc/opendomo/speech/portmenu.txt |sed  -e "s/Port:/puerto /" |sed -e "s/:/ diga, control puerto {$par1} /" >> /tmp/tmp.txt
					fi	
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			controlrefresco)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# In this case, it is necessary to list the available card id, so that user can 					#choose. This will imply a new state 
					i=0
					echo -n "" > /tmp/ctrl2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0]
						then
							# cambiar el campo 2 por el parametro $par2
							# Sacar todos los campos y sustituir el 2 por $card
							#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
							card=`cat /tmp/tmp.txt | cut -d":" -f2`
							port=`cat /tmp/tmp.txt | cut -d":" -f3`
							ip=`cat /tmp/tmp.txt | cut -d":" -f5`
							user=`cat /tmp/tmp.txt | cut -d":" -f6`
							passw=`cat /tmp/tmp.txt | cut -d":" -f7`
							inf=`cat /tmp/tmp.txt | cut -d":" -f8`
							line=$par1":"$card":"$port":"$par2":"$ip":"$user":"$passw":"$inf		
							
						fi
						echo $line >> /tmp/ctrl2.txt
					done < /tmp/ctrl.txt
					cp /tmp/ctrl2.txt /tmp/ctrl.txt
					rm /tmp/ctrl2.txt					
						
					echo "Dispositivo " $par1 "tiempo de refresco " $par2 " Para confirmar el cambio diga control ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt					
				;;
			controlIP)
				par2=`echo $2 |cut -d " " -f2`
				par3=`echo $2 |cut -d " " -f3`
				par4=`echo $2 |cut -d " " -f4`
				par5=`echo $2 |cut -d " " -f5`			
				IP=$par2"."$par3"."$par4"."$par5				
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# leer linea de usr.txt y cambiar la que tiene $2 por $2:usuario a borrar
					i=0
					echo -n "" > /tmp/ctrl2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							# Sacar todos los campos y sustituir el 2 por $card
							#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
							card=`cat /tmp/tmp.txt | cut -d":" -f2`
							port=`cat /tmp/tmp.txt | cut -d":" -f3`
							refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
							ip=`cat /tmp/tmp.txt | cut -d":" -f5`
							user=`cat /tmp/tmp.txt | cut -d":" -f6`
							passw=`cat /tmp/tmp.txt | cut -d":" -f7`
							inf=`cat /tmp/tmp.txt | cut -d":" -f8`
							line=$par1":"$card":"$port":"$refresh":"$IP":"$user":"$passw":"$inf	
						fi
						echo $line >> /tmp/ctrl2.txt
					done < /tmp/ctrl.txt
					cp /tmp/ctrl2.txt /tmp/ctrl.txt
					rm /tmp/ctrl2.txt					
						
					echo "Dispositivo " $par1 " IP " $IP " Para confirmar el cambio diga control ejecutar" $par1  > /tmp/tmp.txt
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt				
				;;
			controlusuario)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# leer linea de ctrl.txt y cambiar la que tiene $2 por $2:datos de clave
					i=0
					echo -n "" > /tmp/ctrl2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							# Sacar todos los campos y sustituir el 2 por $card
							#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
							card=`cat /tmp/tmp.txt | cut -d":" -f2`
							port=`cat /tmp/tmp.txt | cut -d":" -f3`
							refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
							ip=`cat /tmp/tmp.txt | cut -d":" -f5`
							user=`cat /tmp/tmp.txt | cut -d":" -f6`
							passw=`cat /tmp/tmp.txt | cut -d":" -f7`
							inf=`cat /tmp/tmp.txt | cut -d":" -f8`
							line=$par1":"$card":"$port":"$refresh":"$ip":"$par2":"$passw":"$inf	
						fi
						echo $line >> /tmp/ctrl2.txt
					done < /tmp/ctrl.txt
					cp /tmp/ctrl2.txt /tmp/ctrl.txt
					rm /tmp/ctrl2.txt					
						
					echo "Dispositivo " $par1 "  usuario " $par2 " Para confirmar el cambio diga control guardar" $par1  > /tmp/tmp.txt
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt						
				;;
			controlclave)
				if [ `grep -c $par1 /tmp/ctrl.txt` -gt 0 ]
				then
					# leer linea de ctrl.txt y cambiar la que tiene $2 por $2:datos de clave
					i=0
					echo -n "" > /tmp/ctrl2.txt
					while read line
					do	
						((i++))		
						echo $line > /tmp/tmp.txt
						if [ `grep -c $par1 /tmp/tmp.txt` -gt 0 ]
						then
							# cambiar el campo 2 por el parametro $par2
							# Sacar todos los campos y sustituir el 2 por $card
							#devicename:cardtype:port:refresh:IP:user:password:borrar/nuevo
							card=`cat /tmp/tmp.txt | cut -d":" -f2`
							port=`cat /tmp/tmp.txt | cut -d":" -f3`
							refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
							ip=`cat /tmp/tmp.txt | cut -d":" -f5`
							user=`cat /tmp/tmp.txt | cut -d":" -f6`
							passw=`cat /tmp/tmp.txt | cut -d":" -f7`
							inf=`cat /tmp/tmp.txt | cut -d":" -f8`
							line=$par1":"$card":"$port":"$refresh":"$ip":"$user":"$par2":"$inf	
						fi
						echo $line >> /tmp/ctrl2.txt
					done < /tmp/ctrl.txt
					cp /tmp/ctrl2.txt /tmp/ctrl.txt
					rm /tmp/ctrl2.txt					
						
					echo "Dispositivo " $par1 " Clave de usuario " $par2 " Para confirmar el cambio diga control guardar" $par1  > /tmp/tmp.txt
				else
					echo "El dispositivo " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt						
				;;
			controlejecutar)
				#Don't do anything here, do it after, helping in other case, with option usuario ayuda 
				;;
			controlayuda|else)
				$ESPEAK "Menu de configuracion de puertos de control. Puertos actuales "
				Generate_control_data				
				$ESPEAK < /tmp/tmp.txt
				/usr/local/opendomo/vr/espeak.sh MenuControlConfig
				;;
		esac
				
		if [ "$1" = "controlejecutar" ]
		then			
			grep $par1 /tmp/ctrl.txt > /tmp/tmp.txt
			if [ `grep -c "borrar" /tmp/tmp.txt` -gt 0 ]
			then
				/usr/local/opendomo/delControlDevice.sh $par1
				echo "Dispositivo " $par1 " ha sido borrado " > /tmp/tmp.txt
			else
				if [ `grep -c "nuevo" /tmp/tmp.txt` -gt 0 ]
				then
					mkdir /etc/opendomo/control/$par1
				fi
				dirname=$par1			
				model=`cat /tmp/tmp.txt | cut -d":" -f2`
				port=`cat /tmp/tmp.txt | cut -d":" -f3`
				refresh=`cat /tmp/tmp.txt | cut -d":" -f4`
				ip=`cat /tmp/tmp.txt | cut -d":" -f5`
				username=`cat /tmp/tmp.txt | cut -d":" -f6`
				password=`cat /tmp/tmp.txt | cut -d":" -f7`
				if [ $port=="" || $model=="" ]
				then
					echo "Necesita configurar el puerto y la placa antes de poder ejecutar el cambio en " $par1 > /tmp/tmp.txt
				else			
					echo "Dispositivo " $par1 " ha sido creado " > /tmp/tmp.txt
					echo "
device='$port'
driver='$model'
dirname='$dirname'
refresh='$refresh'
username='$username'
password='$password'
ip='$ip'
" > /etc/opendomo/control/$dirname.conf
					
					
				fi
			fi			
			$ESPEAK < /tmp/tmp.txt
			Retrieve_control_data
		else
			$ESPEAK "Si necesita ayuda para modificar datos de dispositivo de control, diga control ayuda"
		fi
		;;
#Menu de configuracion general de estados del sistema
	menu3xstat)	
		par1=`echo $2 |cut -d " " -f1 -`
		par2=`echo $2 |cut -d " " -f2 -`
		par3=`echo $2 |cut -d " " -f3 -`
		par4=`echo $2 |cut -d " " -f4 -`
		case "$1" in
			estadocrear)
				if [ `grep -c $par1 /tmp/stat.txt` -eq 0 ]
				then
					/usr/local/opendomo/addSystemState.sh new $par1
					echo "Estado " $par1 " ha sido creado con todos los demonios desactivados. Para modificar el comportamiento dida, estado modificar" $par1 > /tmp/tmp.txt 
					echo $par1 >> /tmp/stat.txt
				else
					echo "El estado " $par1 " ya existe" >> /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt	
				;;
			estadoborrar)
				
				if [ `grep -c $par1 /tmp/stat.txt` -gt 0 ]
				then
					# leer linea de stat.txt, borrar el estado y regenerar /tmp/stat.txt después del comando de borrado..
					/usr/local/opendomo/delSystemState.sh $par1
					ls -l /etc/opendomo/states | awk '{ print $9}' > /tmp/stat.txt
					#Si sigue estando, porque hubo un error en delSystemState.sh no ha sido borrado.
					if [ `grep -c $par1 /tmp/stat.txt` -gt 0 ]
					then
						echo "Estado " $par1 " No ha sido borrado " > /tmp/tmp.txt
					else
						echo "Estado " $par1 " Ha sido borrado"  > /tmp/tmp.txt
					fi
				else
					echo "El estado " $par1 " no existe" > /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt				
				;;
			estadomod)
				#El estado a modificar se almacena en /var/opendomo/tmp/state.tmp. Sobre este estado se puede activar o desactivar los daemons. 
				# Para hacerlo es necesario crear un nuevo estado: menu3xstatmod. 
				if [ `grep -c $par1 /tmp/stat.txt` -gt 0 ]
				then
					#preparamos la modificacion. Se acualiza /var/opendomo/tmp/state.tmp
					/usr/local/opendomo/editSystemState.sh $par1 |grep subcommand  | awk '{print $1} ' > /tmp/tmp.txt
					i=0
					echo -n "" > /tmp/stat2.txt
					while read line
					do	
						((i++))		
						echo -n $line > /tmp/tmp2.txt
						if test -f /etc/opendomo/states/$par1/$line ;
						then
							echo " numero " $i " estado activo : si " >> /tmp/tmp2.txt
						else
							echo " numero " $i " estado activo : no" >> /tmp/tmp2.txt
						fi
						cat /tmp/tmp2.txt >> /tmp/stat2.txt
						rm /tmp/tmp2.txt
					done < /tmp/tmp.txt				
					echo "Estado " $par1 " estado actual de demonios "  > /tmp/tmp.txt
					cat /tmp/stat2.txt >> /tmp/tmp.txt 
					echo " Diga , estado activar numero para activar un demonio, o , estado desactivar numero para desactivar un demonio " >> /tmp/tmp.txt
					echo "menu3xstatmod" > /usr/local/opendomo/vr/MENU
				else
					echo "El estado " $par1 " no existe" >> /tmp/tmp.txt
				fi
				$ESPEAK < /tmp/tmp.txt	
				;;
			estadoayuda|else)
				$ESPEAK "Menu de configuracion de estados del sistema. Estados actuales "
				#create temporary file for keeping provisional states data, until new states data data is saved 
			  	ls -l /etc/opendomo/states | awk '{ print $9}' > /tmp/stat.txt
				$ESPEAK < /tmp/stat.txt
				/usr/local/opendomo/vr/espeak.sh MenuStatConfig
				;;
			estadoejecutar)
				i=0
				while read line
				do	
					((i++))		
					daemon=`echo $line | awk ' {print $1}'`
					valor=`echo $line | awk ' {print $7}'`
					if [ "$valor" = "si" ]
					then
						/usr/local/opendomo/editSystemState.sh $daemon "on"
					else
					
						/usr/local/opendomo/editSystemState.sh $daemon "off"
					fi
				done < /tmp/stat2.txt
				echo "Estado " $par1 " ha sido guardado, con los siguientes datos "  > /tmp/tmp.txt
				cat /tmp/stat2.txt >> /tmp/tmp.txt 
				$ESPEAK < /tmp/tmp.txt	
				;;
		esac
		;;
	#Menu de configuracion de un estado particular del sistema
	menu3xstatmod)	
		par1=`echo $2 |cut -d " " -f1 -`
		par2=`echo $2 |cut -d " " -f2 -`
		par3=`echo $2 |cut -d " " -f3 -`
		par4=`echo $2 |cut -d " " -f4 -`
		estado=`cat /var/opendomo/tmp/state.tmp` 
		case "$1" in
			estadoactivar|estadodesactivar)				
				i=0
				echo -n "" > /tmp/tmp2.txt
				while read line
				do	
					((i++))		
					if [ "$i" == "$par3" ]
					then
						daemon=`echo $line | cut -d" " -f1`
						echo -n $daemon >> /tmp/tmp2.txt
						if [ "$1" == "estadoactivar" ]
						then
							echo " numero " $i " estado activo : si " >> /tmp/tmp2.txt
						else 
							echo " numero " $i " estado activo : no " >> /tmp/tmp2.txt
						fi					
					else
						echo $line >> /tmp/tmp2.txt
					fi
				done < /tmp/stat2.txt
				cp /tmp/tmp2.txt /tmp/stat2.txt
				rm /tmp/tmp2.txt
				echo " El estado " $estado " ha sido marcado para modificacion. Valores actuales: " > /tmp/tmp.txt
				cat /tmp/stat2.txt >> /tmp/tmp.txt
				echo " Diga , estado ejecutar " $estado " para guardar los cambios " >> /tmp/tmp.txt
				;;
			estadoejecutar)
				if [ "$estado" == "$par1" ]
				then				
					i=0
					while read line
					do	
						((i++))		
						daemon=`echo $line | awk ' {print $1}'`
						valor=`echo $line | awk ' {print $7}'`
						if [ "$valor" = "si" ]
						then
							/usr/local/opendomo/editSystemState.sh $daemon "on"
						else
							/usr/local/opendomo/editSystemState.sh $daemon "off"
						fi
					done < /tmp/stat2.txt
					echo "Estado " $estado " ha sido guardado, con los siguientes datos "  > /tmp/tmp.txt
					cat /tmp/stat2.txt >> /tmp/tmp.txt
				else
					echo "Estado " $par1 " no esta preparado para modificar " > /tmp/tmp.txt
					echo "Solo puede modificar el estado " $estado >> /tmp/tmp.txt					 
				fi
				;;
			else)
				echo " Estado " $estado " Valores actuales: " > /tmp/tmp.txt
				cat /tmp/stat2.txt >> /tmp/tmp.txt
				echo " Diga , estado activar numero para activar un demonio, o , estado desactivar numero para desactivar un demonio " >> /tmp/tmp.txt
				echo " Diga , estado ejecutar " $estado " para guardar los cambios " >> /tmp/tmp.txt
				;;
			esac
		echo " Para volver al menu anterior, diga , volver. Para salir del modo menu, diga , salir " >> /tmp/tmp.txt
		$ESPEAK < /tmp/tmp.txt	
		;;
	#Menu de configuracion general de plugins del sistema
	menu3xplug)	
			case "$1" in
				pluginact)
					par1=`echo $2 |cut -d " " -f1 -`
					if [ `grep -c $par1 /tmp/plugin.txt` -gt 0 ]
					then		
						plugin=`grep $par1 /tmp/plugin.txt | awk '{print $1}' | sed 's/-//g'`	
						if [ `grep $par1 /tmp/plugin.txt | grep -c "no instalado"` -gt 0 ]
						then
							/usr/local/opendomo/installPlugin.sh $plugin
							echo "El complemento " $plugin " ha sido instalado " > /tmp/tmp.txt 
						else
							echo "El complemento " $plugin " ya esta instalado" >> /tmp/tmp.txt
						fi
					else
						echo " No existe el numero de complemento " $par1 > /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt
					Generate_plugin_data	
					;;
				plugindeact)
					par1=`echo $2 |cut -d " " -f1 -`
					if [ `grep -c $par1 /tmp/plugin.txt` -gt 0 ]
					then	
						plugin=`grep $par1 /tmp/plugin.txt | awk '{print $1}' | sed 's/-//g'`
						if [ `grep $par1 /tmp/plugin.txt | grep -c "no instalado"` -eq 0 ]
						then
							/usr/local/opendomo/removePlugin.sh $plugin
							echo "El complemento " $plugin " ha sido eliminado " > /tmp/tmp.txt 
						else
							echo "El complemento " $plugin " no esta instalado" >> /tmp/tmp.txt
						fi
					else
						echo " No existe el numero de complemento " $par1 > /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt
					Generate_plugin_data		
					;;
				pluginupd)
					usr/local/opendomo/updatePlugins.sh
					$ESPEAK  " Los complementos han sido actualizados con las ultimas versiones oficiales"
					;;
				systemupd)
					usr/local/opendomo/updateSystem.sh
					$ESPEAK  " El sistema ha sido actualizado con las ultimas versiones oficiales"
					;;
				pluginayuda|else)
					$ESPEAK "Menu de configuracion de complementos del sistema. Estado actual  "
					$ESPEAK < /tmp/plugin.txt
					/usr/local/opendomo/vr/espeak.sh MenuPlugConfig
					;;
			esac
			;;
#Menu de configuracion de zonas del sistema
	menu3xzon)	
			case "$1" in
				zonacrear)
					zona=`echo $2 |cut -d ":" -f1 -`
					if [ `grep -c $zona /tmp/zone.txt` -eq 0 ]
					then		
						echo $zona "::nueva:" >> /tmp/zone.txt
						echo " La zona " $zona " ha sido marcada para crear. Diga, zona ejecutar " $zona " para aplicar el cambio"  > /tmp/tmp.txt
					else
						echo " Ya existe la zona " $zona >> /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt	
					;;
				zonaborrar)
					zona=`echo $2 |cut -d ":" -f1 -`
					if [ `grep -c $zona /tmp/zone.txt` -gt 0 ]
					then	
						echo -n "" > /tmp/tmp.txt	
						while read line
						do		
							if [ `echo $line | grep -c $zona` -gt 0 ]
							then
								echo $line | sed 's/zone/borrar/' | sed 's/nueva/borrar/' >> /tmp/tmp.txt
							else
								echo $line >> /tmp/tmp.txt
							fi
						done < /tmp/zone.txt
						cp /tmp/tmp.txt /tmp/zone.txt
						echo " La zona " $zona " ha sido marcada para borrar. Diga, zona ejecutar " $zona " para aplicar el cambio"  > /tmp/tmp.txt
					else
						echo " No existe la zona " $zona >> /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt	
					;;
				zonadesc)
					zona=`echo $2 |cut -d" " -f1 -`
					descr=`echo $2 |cut -d" " -f2 -`
					if [ `grep -c $zona /tmp/zone.txt` -gt 0 ]
					then	
						echo -n "" > /tmp/tmp.txt	
						while read line
						do		
							if [ `echo $line | grep -c $zona` -gt 0 ]
							then
								par1=`echo $line | cut -d":" -f1 -`
								par3=`echo $line | cut -d":" -f3 -`
								par4=`echo $line | cut -d":" -f4 -`
								echo $par1 ":" $descr ":" $par3 ":" $par4 >> /tmp/tmp.txt
							else
								echo $line >> /tmp/tmp.txt
							fi
						done < /tmp/zone.txt
						cp /tmp/tmp.txt /tmp/zone.txt
						echo " En la zona" $zona " se ha marcado la descripcion para ser modificada. Diga, zona ejecutar " $zona " para aplicar el cambio"  > /tmp/tmp.txt
					else
						echo " No existe la zona " $zona >> /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt	
					;;
				zonacoord)
					zona=`echo $2 |cut -d" " -f1 -`
					coord1=`echo $2 |cut -d" " -f2 -`
					coord2=`echo $2 |cut -d" " -f3 -`
					coord3=`echo $2 |cut -d" " -f4 -`
					coord4=`echo $2 |cut -d" " -f5 -`
					if [ `grep -c $zona /tmp/zone.txt` -gt 0 ]
					then	
						echo -n "" > /tmp/tmp.txt	
						while read line
						do		
							if [ `echo $line | grep -c $zona` -gt 0 ]
							then
								par1=`echo $line | cut -d":" -f1 -`
								par2=`echo $line | cut -d":" -f2 -`
								par3=`echo $line | cut -d":" -f3 -`
								echo $par1 ":" $par2 ":" $par3 ":" $coord1 "," $coord2 "," $coord3 "," $coord4 >> /tmp/tmp.txt
							else
								echo $line >> /tmp/tmp.txt
							fi
						done < /tmp/zone.txt
						cp /tmp/tmp.txt /tmp/zone.txt
						echo " En la zona" $zona " se ha marcado las cooredenadas para ser modificadas. Diga, zona ejecutar " $zona " para aplicar el cambio"  > /tmp/tmp.txt
					else
						echo " No existe la zona " $zona >> /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt	
					;;
				zonaejecutar)
					zona=`echo $2 |cut -d ":" -f1 -`
					if [ `grep -c $zona /tmp/zone.txt` -gt 0 ]
					then	
						line=`grep $zona /tmp/zone.txt`
						descr=`echo $line | cut -d":" -f2 -`
						coord=`echo $line | cut -d":" -f4 -`
						if [ `echo $line | grep -c borrar` -gt 0 ]
						then
							/usr/local/opendomo/manageZones.sh "delete" $zona
						elif [ `echo $line | grep -c nueva` -gt 0 ]
						then
							/usr/local/opendomo/manageZones.sh "add" $zona $descr $coord
						else
							/usr/local/opendomo/manageZones.sh "update" $zona $descr $coord
						fi	
						echo " Los cambios en la zona " $zona " han sido ejecutados."  > /tmp/tmp.txt
					else
						echo " No existe la zona " $zona >> /tmp/tmp.txt
					fi	
					$ESPEAK < /tmp/tmp.txt	
					;;
				zonaayuda|else)
					$ESPEAK "Menu de configuracion de zonas del sistema. Estado actual  "
					Prepare_actual_zone_data
					$ESPEAK < /tmp/tmp.txt	
					/usr/local/opendomo/vr/espeak.sh MenuZoneConfig
					;;
			esac
			;;
	menu111)
		#Here, use original string($1).No "opcion" prefix in this case prefix is "activar/desactivar"
		#Fields <activar/desactivar> nrzone  
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par2 /etc/opendomo/speech/lightmenu.txt |  cut -d " " -f1 -`
		if [ "$par1" = "activar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/LucesON $zona
		elif [ "$par1" = "desactivar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/LucesOFF $zona
		else
			/usr/local/opendomo/vr/espeak.sh MenuONOFF
		fi		
		;;
	menu112)
		#Here, use original string($1).No "opcion" prefix in this case prefix is "activar/desactivar"
		#Fields <activar/desactivar> nrzone  
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par2 /etc/opendomo/speech/climamenu.txt |  cut -d " " -f1 -`
		if [ "$par1" = "activar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/ClimaON $zona
		elif [ "$par1" = "deactivar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/ClimaOFF $zona
		else
			/usr/local/opendomo/vr/espeak.sh MenuONOFF
		fi		
		;;
	menu113)
		#Here, use original string($1).No "opcion" prefix in this case prefix is "activar/desactivar"
		#Fields <activar/desactivar> nrzone  
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par2 /etc/opendomo/speech/musicmenu.txt |  cut -d " " -f1 -`		

		if [ "$par1" = "activar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/MusicON $zona
		elif [ "$par1" = "desactivar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/MusicOFF $zona
		else
			/usr/local/opendomo/vr/espeak.sh MenuONOFF
		fi		
		;;
	menu114)
		#Here, use original string($1).No "opcion" prefix in this case prefix is "activar/desactivar"		
		#Fields <activar/desactivar> nrzone   
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par2 /etc/opendomo/speech/videomenu.txt |  cut -d " " -f1 -`		 
	
		if [ "$par1" = "activar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/VideoON $zona
		elif [ "$par1" = "desactivar" ]
		then
			/usr/local/opendomo/vr/Recognition/bin/VideoOFF $zona
		else
			/usr/local/opendomo/vr/espeak.sh MenuONOFF
		fi		
		;;
	menu115)
		#Here, "opción" is applicable..., use $p1,filtered
		#Field nrsensor
		 zona=`grep $p1 /etc/opendomo/speech/sensorsmenu.txt |  cut -d " " -f1 -`
		/usr/local/opendomo/vr/Recognition/bin/Sensors $zona
		;;
	menu116)
		#Here, use original string($1)...No "opcion" as prefix in this case
		#Fields "value" nrzone value(ºC)  
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par1 /etc/opendomo/speech/varclimatemenu.txt |  cut -d " " -f1 -`
		#VarClimate has 1 parameter with both parameters, separated by one space
		line=$zona" "$par2
		/usr/local/opendomo/vr/Recognition/bin/VarClimate $line
		;;
	menu117)
		#Here, use original string($1)...No "opcion" as prefix in this case
		#Fields "value" nrzone value(%)  
		par1=`echo $1 |cut -d " " -f1 -`
		par2=`echo $1 |cut -d " " -f2 -`	 
		zona=`grep $par1 /etc/opendomo/speech/varlightmenu.txt |  cut -d " " -f1 -`
		#VarClimate has 1 parameter with both parameters, separated by one space
		line=$zona" "$par2
		/usr/local/opendomo/vr/Recognition/bin/VarLight $line
		;;	 		 			 			 			 			 		 	
	esac
fi

